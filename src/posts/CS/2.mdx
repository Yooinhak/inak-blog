---
title: "Next.js로 생산성을 극대화하는 프론트엔드 아키텍처 설계"
date: 2025-10-21
---

## 1. 개요

프론트엔드 프로젝트가 커질수록 코드 구조는 복잡해지고 유지보수는 어려워집니다.  
Next.js를 중심으로 **Jotai, Tailwind CSS, react-hook-form, AJV, Supabase** 등을 조합하면  
생산성과 안정성을 모두 갖춘 아키텍처를 구축할 수 있습니다.

---

## 2. 기술 스택 구성

| 영역 | 선택 기술 | 이유 |
|------|-------------|------|
| 프레임워크 | **Next.js (App Router)** | SSR/CSR 유연성 + 파일 기반 라우팅 |
| 상태 관리 | **Jotai** | 최소한의 코드로 상태 관리 |
| 스타일링 | **Tailwind CSS** | 빠른 프로토타이핑 + 일관된 디자인 시스템 |
| 폼 관리 | **react-hook-form + AJV resolver** | 유효성 검증과 타입 안전성 보장 |
| 인증 / DB | **Supabase** | Firebase 대체로 빠른 백엔드 구성 |
| 패키지 관리 | **Yarn PnP** | 의존성 충돌 최소화 및 빌드 속도 향상 |

---

## 3. 폴더 구조 설계

Next.js App Router를 사용할 경우, “기능 단위 구조(feature-based structure)”가 이상적입니다.

src/
├─ app/
│  ├─ (auth)/
│  ├─ (dashboard)/
│  └─ layout.tsx
├─ features/
│  ├─ user/
│  │  ├─ hooks/
│  │  ├─ components/
│  │  └─ services/
│  └─ post/
├─ components/
│  └─ common/
├─ lib/
│  ├─ api/
│  ├─ validators/
│  └─ utils/
└─ atoms/

👉 각 기능(feature)이 자체적으로 훅, 서비스, UI를 관리하도록 구성하면  
응집도 높은 코드와 높은 재사용성을 동시에 확보할 수 있습니다.

---

## 4. 커스텀 훅으로 로직 분리

React Hook Form과 AJV를 사용할 때는 폼 로직을 훅으로 분리하면 훨씬 깔끔해집니다.

```tsx
// features/user/hooks/useSignupForm.ts
import { useForm } from "react-hook-form"
import { ajvResolver } from "@hookform/resolvers/ajv"
import schema from "../schemas/signupSchema.json"

export function useSignupForm(onSubmit: (data: any) => void) {
  const form = useForm({
    resolver: ajvResolver(schema),
    mode: "onChange",
  })

  return {
    ...form,
    handleSubmit: form.handleSubmit(onSubmit),
  }
}

뷰 컴포넌트는 단순히 useSignupForm()을 호출하면 되며,
폼 로직은 완전히 재사용 가능한 구조가 됩니다.

⸻

5. Tailwind CSS를 활용한 디자인 시스템

Tailwind는 단순한 유틸리티 모음이 아니라 디자인 일관성을 강제하는 시스템입니다.

export const Button = ({ children, variant = "primary" }) => (
  <button
    className={`
      px-4 py-2 rounded-2xl font-semibold shadow-sm
      ${variant === "primary"
        ? "bg-gradient-to-r from-[#A1C4FD] to-[#C2E9FB] text-white"
        : "bg-gray-200 text-gray-800"}
      hover:opacity-90 transition
    `}
  >
    {children}
  </button>
)

공통 컴포넌트에 테마 기반 스타일을 정의하면
디자이너가 없어도 일관된 UI를 유지할 수 있습니다.

⸻

6. Supabase로 인증 및 데이터 관리 단순화

초기 단계에서는 직접 백엔드를 구축하기보다 Supabase를 활용하면 훨씬 빠릅니다.

import { createClient } from "@supabase/supabase-js"

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_KEY!
)

export const signIn = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signInWithPassword({ email, password })
  if (error) throw error
  return data
}

	•	인증, 권한, DB, Storage를 모두 내장
	•	SQL 기반으로 MySQL 경험을 그대로 활용 가능
	•	클라이언트 SDK를 통해 빠른 프로토타이핑 지원

⸻

7. 개발 생산성을 높이는 규칙

아키텍처의 핵심은 “일관성”입니다.
	1.	로직은 훅으로, 뷰는 컴포넌트로 분리
	2.	공통 패턴은 lib/utils에 모듈화
	3.	atoms(Jotai)로 전역 상태 최소화
	4.	유효성 검증은 AJV로 통일
	5.	모든 API 호출은 fetch wrapper로 관리

이런 규칙만 지켜도, 팀 규모가 커져도 유지보수가 안정적으로 이어집니다.

⸻

8. 정리

Next.js는 단순한 프레임워크가 아니라
**“개발자의 사고방식을 구조화하는 틀”**입니다.

	•	Next.js로 라우팅과 SSR을 단순화하고
	•	Jotai + react-hook-form으로 상태/폼 로직을 안전하게 관리하며
	•	Tailwind로 빠른 UI 구현
	•	Supabase로 초기 백엔드 비용 최소화

이 모든 조합이 맞물리면,
프로젝트는 빠르게 개발되면서도 오래 유지 가능한 구조를 갖추게 됩니다.

⸻

9. 결론

“빠르게 만들되, 오래 버틸 수 있게 짜라.”

이는 수많은 프로젝트를 거치며 얻은 가장 현실적인 아키텍처 원칙입니다.

Next.js는 속도를 위한 도구가 아니라
유지보수를 위한 기반입니다.
초기 설계에 신경쓴다면, 앞으로의 모든 프로젝트는 더 가볍고 빠르게 나아갈 것입니다.

---